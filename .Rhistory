dt.stock$vol_90 <- c(rep(NA, vol_lookback - 1), rollapply(data = dt.stock$returns,width=vol_lookback,FUN=sd) * sqrt(252))
dt.stock <- dt.stock[!is.na(vol_90)]
# Actual volatility is include today's
dt.stock$pred_vol_90 <- c(tail(dt.stock$vol_90, -1), NA)
dt.stock <- dt.stock[!is.na(pred_vol_90)]
return (dt.stock)
}
dt.spy <- funcCalcVolatility(chr.symbol = "SPY",start_date = "2005-01-01", end_date = Sys.Date(), vol_lookback = 90)
dt.ief <- funcCalcVolatility(chr.symbol = "IEF",start_date = "2005-01-01", end_date = Sys.Date(), vol_lookback = 90)
# Calculate portfolio allocation from volatility
dt.return.this <- merge(dt.spy[,list(dt, spy_vol_90=vol_90, spy_pred_vol_90=pred_vol_90)],
dt.ief[,list(dt, ief_vol_90=vol_90, ief_pred_vol_90=pred_vol_90)],
by = c("dt"))
dt.return.this[,spy_proportion_vol_90 := (1/spy_vol_90) / (1/spy_vol_90 + 1/ief_vol_90)]
dt.return.this[,ief_proportion_vol_90 := (1/ief_vol_90) / (1/spy_vol_90 + 1/ief_vol_90)]
dt.return.this[,spy_proportion_vol_90_pred := (1/spy_pred_vol_90) / (1/spy_pred_vol_90 + 1/ief_pred_vol_90)]
dt.return.this[,ief_proportion_vol_90_pred := (1/ief_pred_vol_90) / (1/spy_pred_vol_90 + 1/ief_pred_vol_90)]
# Previous 90 days volatility
dt.weighting_prev <- rbind(dt.return.this[,list(dt, symbol = "SPY", weighting = spy_proportion_vol_90)],
dt.return.this[,list(dt, symbol = "IEF", weighting = ief_proportion_vol_90)])
dt.returns_prev <- funcRunSimpleBacktestPortfolioWeighting(dt.weighting = dt.weighting_prev,
leverage = 1)
# Plot returns
require("PerformanceAnalytics",quietly=TRUE)
charts.PerformanceSummary(dt.returns_prev[,list(dt, ret = daily_ret - 1)])
SharpeRatio.annualized(dt.returns_prev[,list(dt, ret = daily_ret - 1)])
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
parent_dir <- getwd()
source(glue("{parent_dir}/funcAnalyses.R"))
funcGetStockPrice <- function(vec.symbols, start_date = Sys.Date() - 20, end_date = Sys.Date(), bln.all = FALSE,
verbose = FALSE){
dt.return.this <- rbindlist(lapply(1:length(vec.symbols), function(x){
tmp_stock <- vec.symbols[x]
if (verbose){
print(tmp_stock)
print(glue("Progress: {x/length(vec.symbols) * 100}%"))
}
dt.temp <- tryCatch({
if (bln.all){
getSymbols(Symbols = tmp_stock, auto.assign = FALSE)
} else{
getSymbols(Symbols = tmp_stock, from = start_date, to = end_date, auto.assign = FALSE)
}
},
error = function(cond){
return(data.table())
},
warning = function(cond){
return (data.table())
})
if (nrow(dt.temp)){
lst.dates <- index(dt.temp)
dt.temp <- data.table(dt.temp)
dt.temp$date <- lst.dates
dt.temp$symbol <- tmp_stock
colnames(dt.temp) <- c("open", "high", "low", "close", "volume", "adjusted_close", "dt", "symbol")
# Skip stock if volume is 0 but not if it's an index
if (any(dt.temp$volume == 0) & !grepl("%5E", tmp_stock)){
return (data.table())
}
dt.temp$returns <- returns(dt.temp$adjusted_close) + 1
dt.temp <- dt.temp[!is.na(returns)]
return (dt.temp)
} else{
return (data.table())
}
}))
return (dt.return.this)
}
funcCalcVolatility <- function(chr.symbol, start_date, end_date, vol_lookback = 90){
dt.stock  <- funcGetStockPrice(c(chr.symbol), as.Date("1960-01-01"), as.Date(end_date))
dt.stock <- dt.stock[dt >= start_date]
dt.stock$returns <- dt.stock$returns - 1
# Calculate volatility using the previous n days annualized returns volatility
dt.stock$vol_90 <- c(rep(NA, vol_lookback - 1), rollapply(data = dt.stock$returns,width=vol_lookback,FUN=sd) * sqrt(252))
dt.stock <- dt.stock[!is.na(vol_90)]
# Actual volatility is include today's
dt.stock$pred_vol_90 <- c(tail(dt.stock$vol_90, -1), NA)
dt.stock <- dt.stock[!is.na(pred_vol_90)]
return (dt.stock)
}
dt.spy <- funcCalcVolatility(chr.symbol = "SPY",start_date = "2004-01-01", end_date = Sys.Date(), vol_lookback = 90)
dt.ief <- funcCalcVolatility(chr.symbol = "IEF",start_date = "2004-01-01", end_date = Sys.Date(), vol_lookback = 90)
# Calculate portfolio allocation from volatility
dt.return.this <- merge(dt.spy[,list(dt, spy_vol_90=vol_90, spy_pred_vol_90=pred_vol_90)],
dt.ief[,list(dt, ief_vol_90=vol_90, ief_pred_vol_90=pred_vol_90)],
by = c("dt"))
dt.return.this[,spy_proportion_vol_90 := (1/spy_vol_90) / (1/spy_vol_90 + 1/ief_vol_90)]
dt.return.this[,ief_proportion_vol_90 := (1/ief_vol_90) / (1/spy_vol_90 + 1/ief_vol_90)]
dt.return.this[,spy_proportion_vol_90_pred := (1/spy_pred_vol_90) / (1/spy_pred_vol_90 + 1/ief_pred_vol_90)]
dt.return.this[,ief_proportion_vol_90_pred := (1/ief_pred_vol_90) / (1/spy_pred_vol_90 + 1/ief_pred_vol_90)]
# Previous 90 days volatility
dt.weighting_prev <- rbind(dt.return.this[,list(dt, symbol = "SPY", weighting = spy_proportion_vol_90)],
dt.return.this[,list(dt, symbol = "IEF", weighting = ief_proportion_vol_90)])
dt.returns_prev <- funcRunSimpleBacktestPortfolioWeighting(dt.weighting = dt.weighting_prev,
leverage = 1)
# Plot returns
require("PerformanceAnalytics",quietly=TRUE)
charts.PerformanceSummary(dt.returns_prev[,list(dt, ret = daily_ret - 1)])
SharpeRatio.annualized(dt.returns_prev[,list(dt, ret = daily_ret - 1)])
dt.return.this
dt.spy
dt.ief
funcGetStockPrice("SPY", as.Date("1960-01-01"), Sys.Date())
funcGetStockPrice("IEF", as.Date("1960-01-01"), Sys.Date())
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
parent_dir <- getwd()
source(glue("{parent_dir}/funcAnalyses.R"))
funcGetStockPrice <- function(vec.symbols, start_date = Sys.Date() - 20, end_date = Sys.Date(), bln.all = FALSE,
verbose = FALSE){
dt.return.this <- rbindlist(lapply(1:length(vec.symbols), function(x){
tmp_stock <- vec.symbols[x]
if (verbose){
print(tmp_stock)
print(glue("Progress: {x/length(vec.symbols) * 100}%"))
}
dt.temp <- tryCatch({
if (bln.all){
getSymbols(Symbols = tmp_stock, auto.assign = FALSE)
} else{
getSymbols(Symbols = tmp_stock, from = start_date, to = end_date, auto.assign = FALSE)
}
},
error = function(cond){
return(data.table())
},
warning = function(cond){
return (data.table())
})
if (nrow(dt.temp)){
lst.dates <- index(dt.temp)
dt.temp <- data.table(dt.temp)
dt.temp$date <- lst.dates
dt.temp$symbol <- tmp_stock
colnames(dt.temp) <- c("open", "high", "low", "close", "volume", "adjusted_close", "dt", "symbol")
# Skip stock if volume is 0 but not if it's an index
if (any(dt.temp$volume == 0) & !grepl("%5E", tmp_stock)){
return (data.table())
}
dt.temp$returns <- returns(dt.temp$adjusted_close) + 1
dt.temp <- dt.temp[!is.na(returns)]
return (dt.temp)
} else{
return (data.table())
}
}))
return (dt.return.this)
}
funcCalcVolatility <- function(chr.symbol, start_date, end_date, vol_lookback = 90){
dt.stock  <- funcGetStockPrice(c(chr.symbol), as.Date("1960-01-01"), as.Date(end_date))
dt.stock <- dt.stock[dt >= start_date]
dt.stock$returns <- dt.stock$returns - 1
# Calculate volatility using the previous n days annualized returns volatility
dt.stock$vol_90 <- c(rep(NA, vol_lookback - 1), rollapply(data = dt.stock$returns,width=vol_lookback,FUN=sd) * sqrt(252))
dt.stock <- dt.stock[!is.na(vol_90)]
# Actual volatility is include today's
dt.stock$pred_vol_90 <- c(tail(dt.stock$vol_90, -1), NA)
dt.stock <- dt.stock[!is.na(pred_vol_90)]
return (dt.stock)
}
dt.spy <- funcCalcVolatility(chr.symbol = "SPY",start_date = "2002-01-01", end_date = Sys.Date(), vol_lookback = 90)
dt.ief <- funcCalcVolatility(chr.symbol = "IEF",start_date = "2002-01-01", end_date = Sys.Date(), vol_lookback = 90)
# Calculate portfolio allocation from volatility
dt.return.this <- merge(dt.spy[,list(dt, spy_vol_90=vol_90, spy_pred_vol_90=pred_vol_90)],
dt.ief[,list(dt, ief_vol_90=vol_90, ief_pred_vol_90=pred_vol_90)],
by = c("dt"))
dt.return.this[,spy_proportion_vol_90 := (1/spy_vol_90) / (1/spy_vol_90 + 1/ief_vol_90)]
dt.return.this[,ief_proportion_vol_90 := (1/ief_vol_90) / (1/spy_vol_90 + 1/ief_vol_90)]
dt.return.this[,spy_proportion_vol_90_pred := (1/spy_pred_vol_90) / (1/spy_pred_vol_90 + 1/ief_pred_vol_90)]
dt.return.this[,ief_proportion_vol_90_pred := (1/ief_pred_vol_90) / (1/spy_pred_vol_90 + 1/ief_pred_vol_90)]
# Previous 90 days volatility
dt.weighting_prev <- rbind(dt.return.this[,list(dt, symbol = "SPY", weighting = spy_proportion_vol_90)],
dt.return.this[,list(dt, symbol = "IEF", weighting = ief_proportion_vol_90)])
dt.returns_prev <- funcRunSimpleBacktestPortfolioWeighting(dt.weighting = dt.weighting_prev,
leverage = 1)
# Plot returns
require("PerformanceAnalytics",quietly=TRUE)
charts.PerformanceSummary(dt.returns_prev[,list(dt, ret = daily_ret - 1)])
SharpeRatio.annualized(dt.returns_prev[,list(dt, ret = daily_ret - 1)])
dt.spy
dt.ief
dt.returns_prev
dt.returns <- dt.returns_prev
dt.returns
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
parent_dir <- getwd()
source(glue("{parent_dir}/funcAnalyses.R"))
funcGetStockPrice <- function(vec.symbols, start_date = Sys.Date() - 20, end_date = Sys.Date(), bln.all = FALSE,
verbose = FALSE){
dt.return.this <- rbindlist(lapply(1:length(vec.symbols), function(x){
tmp_stock <- vec.symbols[x]
if (verbose){
print(tmp_stock)
print(glue("Progress: {x/length(vec.symbols) * 100}%"))
}
dt.temp <- tryCatch({
if (bln.all){
getSymbols(Symbols = tmp_stock, auto.assign = FALSE)
} else{
getSymbols(Symbols = tmp_stock, from = start_date, to = end_date, auto.assign = FALSE)
}
},
error = function(cond){
return(data.table())
},
warning = function(cond){
return (data.table())
})
if (nrow(dt.temp)){
lst.dates <- index(dt.temp)
dt.temp <- data.table(dt.temp)
dt.temp$date <- lst.dates
dt.temp$symbol <- tmp_stock
colnames(dt.temp) <- c("open", "high", "low", "close", "volume", "adjusted_close", "dt", "symbol")
# Skip stock if volume is 0 but not if it's an index
if (any(dt.temp$volume == 0) & !grepl("%5E", tmp_stock)){
return (data.table())
}
dt.temp$returns <- returns(dt.temp$adjusted_close) + 1
dt.temp <- dt.temp[!is.na(returns)]
return (dt.temp)
} else{
return (data.table())
}
}))
return (dt.return.this)
}
funcCalcVolatility <- function(chr.symbol, start_date, end_date, vol_lookback = 90){
dt.stock  <- funcGetStockPrice(c(chr.symbol), as.Date("1960-01-01"), as.Date(end_date))
dt.stock <- dt.stock[dt >= start_date]
dt.stock$returns <- dt.stock$returns - 1
# Calculate volatility using the previous n days annualized returns volatility
dt.stock$vol_90 <- c(rep(NA, vol_lookback - 1), rollapply(data = dt.stock$returns,width=vol_lookback,FUN=sd) * sqrt(252))
dt.stock <- dt.stock[!is.na(vol_90)]
# Actual volatility is include today's
dt.stock$pred_vol_90 <- c(tail(dt.stock$vol_90, -1), NA)
dt.stock <- dt.stock[!is.na(pred_vol_90)]
return (dt.stock)
}
dt.spy <- funcCalcVolatility(chr.symbol = "SPY",start_date = "2003-01-01", end_date = Sys.Date(), vol_lookback = 90)
dt.ief <- funcCalcVolatility(chr.symbol = "IEF",start_date = "2003-01-01", end_date = Sys.Date(), vol_lookback = 90)
# Calculate portfolio allocation from volatility
dt.return.this <- merge(dt.spy[,list(dt, spy_vol_90=vol_90, spy_pred_vol_90=pred_vol_90)],
dt.ief[,list(dt, ief_vol_90=vol_90, ief_pred_vol_90=pred_vol_90)],
by = c("dt"))
dt.return.this[,spy_proportion_vol_90 := (1/spy_vol_90) / (1/spy_vol_90 + 1/ief_vol_90)]
dt.return.this[,ief_proportion_vol_90 := (1/ief_vol_90) / (1/spy_vol_90 + 1/ief_vol_90)]
dt.return.this[,spy_proportion_vol_90_pred := (1/spy_pred_vol_90) / (1/spy_pred_vol_90 + 1/ief_pred_vol_90)]
dt.return.this[,ief_proportion_vol_90_pred := (1/ief_pred_vol_90) / (1/spy_pred_vol_90 + 1/ief_pred_vol_90)]
# Previous 90 days volatility
dt.weighting_prev <- rbind(dt.return.this[,list(dt, symbol = "SPY", weighting = spy_proportion_vol_90)],
dt.return.this[,list(dt, symbol = "IEF", weighting = ief_proportion_vol_90)])
dt.returns_prev <- funcRunSimpleBacktestPortfolioWeighting(dt.weighting = dt.weighting_prev,
leverage = 1)
dt.returns_prev
dt.returns_prev
dt.returns
runApp('~/GitHub/edav_final_project/shiny_app')
runApp('~/GitHub/edav_final_project/shiny_app')
runApp('~/GitHub/edav_final_project/shiny_app')
runApp('~/GitHub/edav_final_project/shiny_app')
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
parent_dir <- getwd()
parent_dir
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
parent_dir <- getwd()
setwd("..")
parent_dir <- getwd()
parent_dir
dt.data <- fread(paste0(parent_dir, "/health_care_data/master.csv"))
runApp('shiny_app')
runApp('shiny_app')
runApp('shiny_app')
runApp('shiny_app')
runApp('shiny_app')
dt.data
dt.data <- fread(paste0(parent_dir, "/health_care_data/master.csv"))
dt.data
colnames(dt.data)
library(data.table)
library(glue)
library(vcd)
library(tidyverse)
########################
#Michelle Exploration###
########################
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
parent_dir <- getwd()
dt.master <-fread(glue("{parent_dir}/health_care_data/master.csv"))
cat_records_breached <- dt.master %>% filter(records_breached <1000000& !is.na(records_breached)) %>% select(records_breached, cat_name)
ggplot(data = cat_records_breached,aes(x = reorder(cat_name,records_breached,FUN =median), y =records_breached)) + geom_boxplot() + coord_flip() + ggtitle("Distribution of Records Breached Across Category/Industry") + ylab("# Records Breached") + xlab("")
state_records_breached <-dt.master %>%filter(!is.na(records_breached) & records_breached <100000) %>% select(state, records_breached)
ggplot(data = state_records_breached,aes(x = reorder(state,records_breached,FUN =median), y =records_breached)) + geom_boxplot() + coord_flip() + ggtitle("Distribution of Records Breached Across States") + ylab("# Records Breached") + xlab("")
region_records_breached <-dt.master %>%filter(!is.na(records_breached) & records_breached <50000 & region!="" & region!="Puerto Rico") %>% select(region, records_breached, state)
ggplot(data = region_records_breached,aes(x = reorder(region,records_breached,FUN =median), y =records_breached)) + geom_boxplot() + coord_flip() + ggtitle("Distribution of Records Breached Across Region") + ylab("# Records Breached") + xlab("")
###################
#Yimin Exploration#
###################
dt.master$total_records<-as.numeric(dt.master$total_records)
str(dt.master)
#Region by Breach_Type Mosaic Plot
counts1 <- dt.master %>% filter(region!= "Argentina" & region!="Puerto Rico") %>% group_by(region, breach_type) %>% summarize(Freq = n()) %>% arrange(desc(Freq))
counts1$breach_type <-factor(counts1$breach_type, levels = c('UNKN','STAT','INSD','PORT', 'PHYS','DISC','HACK'))
mosaic(breach_type~region, counts1,
rot_labels = c(10,0,0, 30),
direction = c('v', 'h'))
#Category, Breach_Type Occurence
table(dt.master$category)
counts2 <- dt.master %>% filter(region!= "Argentina" & region!="Puerto Rico") %>% group_by(category, breach_type) %>% summarize(Freq = n()) %>% arrange(desc(Freq))
ggplot(data = counts2[1:10,], aes(x=reorder(category,-Freq), y = Freq))+
geom_bar(stat = "identity") + xlab("Category") +
ylab("Occurences of Breaches") +
ggtitle("How Often Breaches Occur to Specific Categories") +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
counts2
#Breach_Type breakdown within Physician, Hospital category
counts3 <- counts2 %>% filter(category =="Physician, Hospital")
physician_cat_breach<-ggplot(data = counts3,aes(x = reorder(breach_type,Freq), y =Freq)) +
geom_col() + coord_flip() +
ggtitle("Frequency of each Breach_Type for Physician, Hospital Category") +
ylab("Frequency of Breach Type (Not # records breached)") + xlab("")
physician_cat_breach
#Discussion of visualizations: From the first chart we can see that HACK, DISC, PHYS, PORT are the most common types of data breaches across each of the five regions. In the next chart, I grouped by category and breach_type to see how frequent certain combinations occured. We found that discharge data, payer(insurer), physician/hospital, public health, employer, and researcher were the top 5 categories that were impacted by data breaches. However, this does not necessarily tell us anything about the total number of records breached, but just that these categories are typically targeted. Lastly, I went ahead and further explored the Physician, Hospital category to understand the breakdown of the breach_types: PORT, PHYS, INSD, HACK, DISC were the top give breach_types of the total number of breach occurences to the Physican, hospital category.
counts2
counts1
sum(counts1$Freq)
a <- data.table(counts1)
a
ggplot(data = counts2[1:10,], aes(x=reorder(category,-Freq), y = Freq))+
geom_bar(stat = "identity") + xlab("Category") +
ylab("Occurences of Breaches") +
ggtitle("How Often Breaches Occur to Specific Categories") +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) + theme_bw(base_size = 15)
dt.data
sort(unique(dt.data$category))
physician_cat_breach
runApp('shiny_app')
runApp('shiny_app')
dt.data
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
parent_dir <- getwd()
setwd("..")
parent_dir <- getwd()
dt.data <- fread(paste0(parent_dir, "/health_care_data/master.csv"))
dt.data
dt.data[,dt := as.Date(dt, format = "%m-%d-%Y")]
dt.data
dt.data <- fread(paste0(parent_dir, "/health_care_data/master.csv"))
d
dt.data
dt.data[,dt := as.Date(dt, format = "%m/%d/%Y")]
dt.data
runApp('shiny_app')
runApp('shiny_app')
runApp('shiny_app')
runApp('shiny_app')
runApp('shiny_app')
runApp('shiny_app')
dt.dat
dt.data
unique(dt.data$breach_source)
dt.data[breach_source != ""]
library(glue)
library(tidyquant)
library(data.table)
library(XLConnect)
library(quantmod)
library(lubridate)
# [jyz2111@wrds-cloud-login1-h taqms]$ cd cq
# [jyz2111@wrds-cloud-login1-h cq]$ ls -U | tail -4
# ix_cqm_20181115.sas7bdat
# cqm_20181116.sas7bdat
# cqm_20181116.sas7bndx
# ix_cqm_20181116.sas7bdat
# [jyz2111@wrds-cloud-login1-h cq]$ pwd
# /wrds/nyse/sasdata/taqms/cq
dt_symbol_list <- data.table(TTR::stockSymbols(exchange = "NYSE"))
dt_symbol_list <- dt_symbol_list[!is.na(MarketCap)]
dt_symbol_list <- dt_symbol_list[!is.na(IPOyear) & IPOyear < 2003]
toInteger <- function(income){
amt <- as.numeric(gsub("[A-Z,$]", "", income))
multiplier <- substring(income, nchar(income))
multiplier <- dplyr::case_when(multiplier == "M" ~ 1e6,
multiplier == "B" ~ 1e9,
TRUE ~ 1) # you can add on other conditions for more suffixes
amt*multiplier
}
funcGetTradingDate <- function(start_date, end_date){
vec.dates <- index(getSymbols(Symbols = "SPY", from = start_date, to = end_date, auto.assign = F))
return (vec.dates)
}
# Get top 100 stocks
dt_symbol_list$MarketCap <- toInteger(dt_symbol_list$MarketCap)
dt_symbol_list_final <- head(dt_symbol_list[order(MarketCap, decreasing = TRUE)], 100)
vec.dates <- funcGetTradingDate("2015-01-01", Sys.Date())
vec.dates
a <- c(2, 16, 30, 46, 55)
temp <- 0
for (i in a){
temp <- temp + (i - mean(a))^2
}
temp
b <- c(.44, .82, 1.20, 1.61, 1.83)
mean(b)
a <- c(c(.44, .82, 1.20, 1.61, 1.83))
b <- c(2, 16, 30, 46, 55)
d <- lm(b~a)
a <- c(.44, .82, 1.20, 1.61, 1.83)
b <- c(2, 16, 30, 46, 55)
d <- lm(b~a)
d
cov(a, b)/var(a)
a <- c(.44, .82, 1.20, 1.61, 1.83)
b <- c(2, 16, 30, 46, 55)
temp <- 0
for (i in 1:5){
temp <- temp + (a[i] + 15.10 - 38.0467*b[i])^2
}
temp
plot(a, b)
a <- c(.44, .82, 1.20, 1.61, 1.83)
b <- c(2, 16, 30, 46, 55)
temp <- 0
for (i in 1:5){
temp <- temp + (b[i] + 15.10 - 38.0467*a[i])^2
}
temp
38.0467*1.5-15.10
dnorm(1.96)
dnorm(-1.96)
pnorm(-1.96)
pnorm(1.96)
pnorm(1)
pnorm(1.6)
pnorm(1.65)
pnorm(1.64)
pnorm(1.645)
41.97-1.645
41.97+1.645
library(data.table)
library(ggplot2)
dt.power <- data.table(load_factor = c(84, 81, 73, 74, 67, 87, 77, 76, 69, 82, 90, 88),
cost_coal = c(14, 16, 22, 24, 20, 29, 26, 15, 29, 24, 25, 13),
power_cost = c(4.1, 4.4, 5.6, 5.1, 5.0, 5.3, 5.4, 4.8, 6.1, 5.5, 4.7, 3.9))
dt.power
lm(dt.power$power_cost ~ dt.power$load_factor + dt.power$cost_coal)
my_model <- lm(dt.power$power_cost ~ dt.power$load_factor + dt.power$cost_coal)
my_model
my_model <- glm(dt.power$power_cost ~ dt.power$load_factor + dt.power$cost_coal)
my_model
dt.stocks <- funcGetStockPrice(vec.symbols = c("SPY", "MSFT", "GE"), from = "2010-01-04", to = "2018-11-09")
dt.stocks <- funcGetStockPrice(vec.symbols = c("SPY", "MSFT", "GE"), start_date = "2010-01-04", end_date = "2018-11-09")
dt.stocks
dt.stocks <- dt.stocks[,list(dt, symbol, adjusted_close)]
dt.stocks
dt.stocks <- funcGetStockPrice(vec.symbols = c("SPY", "MSFT", "GE"), start_date = "2010-01-03", end_date = "2018-11-10")
dt.stocks <- dt.stocks[,list(dt, symbol, adjusted_close)]
dt.stocks
dt.stocks <- funcGetStockPrice(vec.symbols = c("SPY", "MSFT", "GE"), start_date = "2010-01-03", end_date = "2018-11-10")
dt.stocks <- dt.stocks[,list(dt, symbol, adjusted_close)]
dt.stocks
dt.final <- merge(merge(dt.stocks[symbol == "SPY"][,list(dt, spy_price = adjusted_close)],
dt.stocks[symbol == "MSFT"][,list(dt, msft_price = adjusted_close)],
by = c("dt")),
dt.stocks[symbol == "GE"][,list(dt, ge_price = adjusted_close)],
by = c("dt"))
dt.final
dt.final[,spy_position := -1000]
dt.final[,msft_position := 3000]
dt.final[,ge_position := 2000]
dt.final
dt.final[,nav := spy_price*spy_position + msft_price*msft_position + ge_price*ge_position]
dt.final
dt.final[,spy_position := -1000]
dt.final[,msft_position := 2000]
dt.final[,ge_position := 3000]
dt.final[,nav := spy_price*spy_position + msft_price*msft_position + ge_price*ge_position]
dt.final
dt.final[,nav := spy_price*spy_position + msft_price*msft_position + ge_price*ge_position + 100000]
dt.final
dt.final[,spy_position := -1000]
dt.final[,msft_position := 2000]
dt.final[,ge_position := 3000]
dt.final[,nav := spy_price*spy_position + msft_price*msft_position + ge_price*ge_position + 100000]
dt.final[,gross_leverage_ratio := (abs(spy_price*spy_position) + abs(msft_price*msft_position) + abs(ge_price*ge_position) + 100000)/nav]
dt.final
ggplot(dt.final, aes(x = dt, y = nav, group = 1)) + geom_line() + theme_bw(base_size = 15) +
xlab("Date") + ylab("NAV")
ggplot(dt.final, aes(x = dt, y = nav, group = 1)) + geom_line() + theme_bw(base_size = 15) +
xlab("Date") + ylab("NAV") + scale_y_continuous(labels = scales::dollar)
# Calculate rolling 90 day volatility
dt.final$vol_90 <- c(rep(NA, 90 - 1), rollapply(data = dt.final$nav,width=90,FUN=sd) * sqrt(250))
dt.final
dt.final.2 <- dt.final[dt >= "2010-06-01"]
dt.final.2
dt.final
head(dt.final$nav, -1) / tail(dt.final$nav, -1)
dt.stocks <- funcGetStockPrice(vec.symbols = c("SPY", "MSFT", "GE"), start_date = "2010-01-03", end_date = "2018-11-10")
dt.stocks <- dt.stocks[,list(dt, symbol, adjusted_close)]
dt.final <- merge(merge(dt.stocks[symbol == "SPY"][,list(dt, spy_price = adjusted_close)],
dt.stocks[symbol == "MSFT"][,list(dt, msft_price = adjusted_close)],
by = c("dt")),
dt.stocks[symbol == "GE"][,list(dt, ge_price = adjusted_close)],
by = c("dt"))
dt.final[,spy_position := -1000]
dt.final[,msft_position := 2000]
dt.final[,ge_position := 3000]
dt.final[,nav := spy_price*spy_position + msft_price*msft_position + ge_price*ge_position + 100000]
dt.final[,gross_leverage_ratio := (abs(spy_price*spy_position) + abs(msft_price*msft_position) + abs(ge_price*ge_position) + 100000)/nav]
# Calculate rolling 90 day volatility
dt.final$nav_ret <- c(NA, head(dt.final$nav, -1) / tail(dt.final$nav, -1))
dt.final
